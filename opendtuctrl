#!/usr/bin/env python3
import requests 
import time 
import sys
from requests.auth import HTTPBasicAuth
import logging
from logging.handlers import TimedRotatingFileHandler
import datetime
import click
import json
import configparser
import humanfriendly.tables as _hf_tables


class Shelly:
    def __init__(self, host, user, pw):
        self.auth = HTTPBasicAuth(user, pw)
        self.headers = {'Content-Type': 'application/json'}
        self.host = f'http://{host}'

    
    def _get(self, path):
        return requests.get(
            url=f'{self.host}{path}',
            headers=self.headers,
            auth=self.auth,
            timeout=5,
            )
    

    def get_meter(self):
        try:
            # Default paths for shelly 3EM
            phase_a = self._get("/emeter/0").json()["power"]
            phase_b = self._get("/emeter/1").json()["power"]    
            phase_c = self._get("/emeter/2").json()["power"]    
            total = phase_a + phase_b + phase_c
        except Exception:
            # Default path for other one phase shelly devices
            phase_a = self._get("/meter/0").json()["power"]
            phase_b = None
            phase_c = None
            total = phase_a

        return {
            "phase_a" : phase_a,
            "phase_b" : phase_b,
            "phase_c" : phase_c,
            "total" : total,
        }
    

    def get_status(self):
        return self._get("/status")


class OpenDtu:

    def __init__(self, host, user, pw):
        self.auth = HTTPBasicAuth(user, pw)
        self.headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        self.host = f'http://{host}/api'


    def _get(self, path):
        return requests.get(
            url=f'{self.host}{path}',
            auth=self.auth,
            headers=self.headers,
            timeout=5,
            )
    

    def _post(self, path, data):
        return requests.post(
            url=f'{self.host}{path}',
            auth=self.auth,
            headers=self.headers,
            data=data,
            timeout=5,
            )


    def get_livedata(self):
        return self._get("/livedata/status/inverters")


    def get_data(self, path):
        return self._get(path)
    
    
    def set_limit(self, limit, serial):
        data = f'data={{"serial":"{serial}", "limit_type":0, "limit_value":{limit}}}'
        return self._post("/limit/config", data)
    

@click.group()
@click.pass_obj
def cli(obj):
    config = configparser.ConfigParser()
    config.read("/opt/opendtuctrl/config/opendtuctrl.ini")
    obj["config"] = config
    dtu_config = config["DTU"]
    obj["dtu01"] = OpenDtu(dtu_config["DTU01"], dtu_config["USER"], dtu_config["PASSWORD"])
    obj["dtu02"] = OpenDtu(dtu_config["DTU02"], dtu_config["USER"], dtu_config["PASSWORD"])
    

@cli.command("get-data")
@click.argument("path")
@click.pass_obj
def get_data(obj, path):
    """Get api data by path"""
    data = obj["dtu01"].get_data(path)
    click.echo(data.content)


@cli.command("list-inverters")
@click.option("--raw", "-r", is_flag=True, default=False, help="Raw output")
@click.pass_obj
def list_inverters(obj, raw):
    """List all configured inverters"""
    try:
        livedata = obj["dtu01"].get_livedata().json()
    except Exception as e:
        click.echo(e)
        exit(1)

    if raw:
        click.echo(json.dumps(livedata))
    else:
        data = []
        columns = ["Name", "Serial", "Reachable", "Producing", "Power(Watt)", "Limit Relative(%)", "Limit absolute(Watt)"]
        for j in livedata["inverters"]:
            data.append(
                [
                    j["name"],
                    j["serial"],
                    j["reachable"],
                    j["producing"],
                    j["AC"]["0"]["Power"]["v"],
                    j["limit_relative"],
                    j["limit_absolute"],
                ],
            )

        click.echo(_hf_tables.format_pretty_table(data, columns))


@cli.command("set-limit")
@click.argument("limit")
@click.argument("serial")
@click.pass_obj
def set_limit(obj, limit, serial):
    """Set inverter limit"""
    try:
        answer = obj["dtu01"].set_limit(limit, serial).json()
        click.echo(answer)
    except Exception as e:
        click.echo(e)
        exit(1)


@cli.command("show-powermeter")
@click.pass_obj
def powermeter(obj):
    """Show powermeter values"""
    pm_config = obj["config"]["POWERMETER"]
    if pm_config["TYPE"] == "shelly":
        pm_client = Shelly(pm_config["HOST"], pm_config["USER"], pm_config["PASSWORD"])
    else:
        click.echo("No support for this device type")
        exit(1)

    try:
        power = pm_client.get_meter()
        click.echo(power)
    except Exception as e:
        click.echo(e)
        exit(1)


@cli.command("dynamic-inverter-control")
@click.pass_obj
def dynamic_inverter_control(obj):
    """Dynamic inverter control"""

    dtu_config = obj["config"]["DTU"]
    pm_config = obj["config"]["POWERMETER"]
    inverter_config = obj["config"]["INVERTER"]

    logpath = "/var/log/opendtuctrl/dic.log"
    logger = logging.getLogger("Dic rotating log")
    logger.setLevel(logging.INFO)
    loghandler = TimedRotatingFileHandler(
        logpath,
        when="midnight",
        interval=1,
        backupCount=0
    )
    loghandler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
    logger.addHandler(loghandler)


    if pm_config["TYPE"] == "shelly":
        pm_client = Shelly(pm_config["HOST"], pm_config["USER"], pm_config["PASSWORD"])
    else:
        click.echo("No support for this type of powermeter")
        exit(1)

    if int(dtu_config["INTERVAL"]) < 4:
        click.echo("Check interval must <= 5 seconds")
        exit(1)

    click.echo(f"Inverter min input = {inverter_config['MIN']}\nInverter max input = {inverter_config['MAX']}")
    click.echo(f"Start inverter control\nCheck interval = {dtu_config['INTERVAL']} seconds")

    def _run():
        # Get inverter data
        try:
            try:
                data = obj["dtu01"].get_livedata().json()
            except Exception:
                try:
                    data = obj["dtu02"].get_livedata().json()
                    logger.warning("DTU01 not reachable, backup DTU02 was used")
                except Exception:
                    logger.warning("No DTU host reachable")

                    return

            configured = False
            for i in data["inverters"]:
                if i["serial"] == inverter_config["SERIAL"]:
                    configured = True
                    dtu_reachable = i["reachable"]
                    current_limit = int(i["limit_absolute"])
                    power = i["AC"]["0"]["Power"]["v"]

            if not configured:
                logger.critical(f"Inverter {inverter_config['SERIAL']} not configured")
                exit(1)

        except Exception as e:
            logger.critical(f"ERROR: {e}")

        # Get powermeter data
        try:
            pm_power = pm_client.get_meter()
            pm_total_power = pm_power["total"]
            pm_reachable = True
        except Exception as e:
            logger.critical(f"ERROR: {e}")
            pm_reachable = False
            pm_total_power = 0
            
        logger.info(f"Purchase from network operator: {round(pm_total_power, 1)} Watt")
        logger.info(f"PV production: {round(power, 1)} Watt")
        logger.info(f"Total consumption: {round(pm_total_power + power, 1)} Watt")

        if dtu_reachable:
            if pm_reachable:
                # Calc new limit
                new_limit = pm_total_power + current_limit - 5 

                if new_limit > int(inverter_config["MAX"]):
                    new_limit = int(inverter_config["MAX"])
                elif new_limit < int(inverter_config["MIN"]):
                    new_limit = int(inverter_config["MIN"])
            else:
                new_limit = int(inverter_config["MIN"])

            if new_limit != current_limit:
                # Set new limit
                logger.info(f'Set inverter limit from {round(current_limit, 1)} to {round(new_limit, 1)} Watt')
                try:
                    new_limit = obj["dtu01"].set_limit(int(new_limit), inverter_config["SERIAL"]).json()
                    logger.info(f'Send new config ({new_limit["type"]})')
                except Exception:
                    try:
                        new_limit = obj["dtu02"].set_limit(int(new_limit), inverter_config["SERIAL"]).json()
                        logger.warning(f'Send new config to backup openDTU ({new_limit["type"]})')
                    except Exception as e:
                        logger.critical(f"Failed to set config.\n{e}")
            else:
                logger.info(f"Current limit of {current_limit} Watt remains unchanged")

        else:
            logger.warning(f"Inverter {inverter_config['SERIAL']} not reachable")

        sys.stdout.flush() 

    while True:

        if dtu_config['START_TIME'] and dtu_config['STOP_TIME']:
            start = datetime.time(int(dtu_config['START_TIME']), 0, 0)
            end = datetime.time(int(dtu_config['STOP_TIME']), 0, 0)
            current = datetime.datetime.now().time()
            if time_in_range(start, end, current):
                _run()
        else:
            _run()
        time.sleep(int(dtu_config["INTERVAL"]))


def time_in_range(start, end, current):
    return start <= current <= end



if __name__ == "__main__":
    cli(obj={})

